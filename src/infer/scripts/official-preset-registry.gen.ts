import { readdir, readFile, writeFile } from "fs/promises";
import { join, basename } from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const OUTPUT_FILENAME = "official-preset-registry.ts";
const OUTPUT_PATH = join(__dirname, "..", OUTPUT_FILENAME);

type PresetInfo = {
    fileName: string;
    exportName: string;
    variableName: string;
}

/**
 * Extract the export name of the preset from the file content
 */
const extractPresetExport = async (filePath: string): Promise<string | null> => {
    const content = await readFile(filePath, "utf-8");

    // Pattern to find "export const XXXPreset: InferPreset = {"
    const exportMatch = content.match(/export\s+const\s+(\w+Preset)\s*:\s*InferPreset/);

    if (exportMatch && exportMatch[1]) {
        return exportMatch[1];
    }

    return null;
}

/**
 * Scan the presets directory and return the information on each preset
 */
const scanPresetsDirectory = async (): Promise<PresetInfo[]> => {
    const presetsDir = join(__dirname, "..", "presets");
    const files = await readdir(presetsDir);

    const presets: PresetInfo[] = [];

    for (const file of files) {
        if (file.endsWith(".ts") && !file.endsWith(".test.ts")) {
            const filePath = join(presetsDir, file);
            const exportName = await extractPresetExport(filePath);

            if (exportName) {
                const fileNameWithoutExt = basename(file, ".ts");
                presets.push({
                    fileName: fileNameWithoutExt,
                    exportName: exportName,
                    variableName: exportName,
                });
            }
        }
    }

    // Sort alphabetically by file name
    presets.sort((a, b) => a.fileName.localeCompare(b.fileName));

    return presets;
}

/**
 * Generate the content of the preset-registry.ts file
 */
const generateRegistryContent = (presets: PresetInfo[]): string => {
    const lines: string[] = [];

    // Header
    lines.push("// This file is auto-generated by src/infer/scripts/official-preset-registry.gen.ts");
    lines.push("// Do not modify manually - run the script to regenerate (npm run gen:presets or yarn gen:presets)");
    lines.push("");

    // Import the type
    lines.push('import { InferPreset } from "./presets.types.js"');

    // Imports the presets
    for (const preset of presets) {
        lines.push(`import { ${preset.exportName} } from "./presets/${preset.fileName}.js"`);
    }

    lines.push("");
    lines.push("export const officialPresetRegistry: Map<string, InferPreset> = new Map();");
    lines.push("");

    // Register the presets
    for (const preset of presets) {
        lines.push(`officialPresetRegistry.set(${preset.variableName}.origin, ${preset.variableName});`);
    }

    lines.push("");

    return lines.join("\n");
}

/**
 * Main function : generate the preset-registry.ts file
 */
export const generateOfficialPresetRegistry = async (): Promise<void> => {
    try {
        console.log("üîç Analyzing the presets directory...");
        const presets = await scanPresetsDirectory();

        console.log(`‚úÖ ${presets.length} presets found :`);
        for (const preset of presets) {
            console.log(`   - ${preset.fileName} (${preset.exportName})`);
        }

        console.log(`\nüìù Generating ${OUTPUT_FILENAME}...`);
        const content = generateRegistryContent(presets);

        await writeFile(OUTPUT_PATH, content, "utf-8");

        console.log(`‚úÖ File generated successfully : ${OUTPUT_FILENAME}`);
    } catch (error) {
        console.error("‚ùå Error generating the preset registry :", error);
        process.exit(1);
    }
}

// Execute if the script is launched directly
if (import.meta.url === `file://${process.argv[1]}`) {
    generateOfficialPresetRegistry();
}


import path from "node:path";
import dnl from "../../index.js";
import { guessSecret } from "../../infer/helpers.js";
import { crossInfer, infer } from "../utils/infer-rule-engine.js";
import fs from "node:fs";
import { ExportError } from "../../errors.js";
import { Import, CrossInferContext, InferContext } from "../../infer/rules.types.js";
import { discoverPresets, findPresetEntry, getPresetsFromNames } from "../../infer/presets.js";
import { InferPreset } from "../../infer/presets.types.js";

export type InferCliOptions = {
    source?: string;
    out?: string;
    force?: boolean;
    dontGuessSecret?: boolean; // if true, the command will not try to guess secret variables
    verbose?: boolean;
    warnOnDuplicates?: boolean;
    presets?: Array<string>;
    discoverPresets?: boolean;
};

export type InferResult = {
    content: string;
    out: string;
    warnings: string[];
    verbose?: Array<string>;
};

export const inferCommand = async (opts?: InferCliOptions | undefined): Promise<InferResult> => {
    const source = path.resolve(process.cwd(), opts?.source ?? ".env");
    if (!fs.existsSync(source)) {
        throw new ExportError(`Source env file not found: ${source}`);
    }
    const out = opts?.out ?? "env.dnl.ts";
    const target = path.resolve(process.cwd(), out);
    if (fs.existsSync(target) && !opts?.force) {
        throw new ExportError(`${out} already exists. Use --force to overwrite.`);
    }
    

    const warnings: string[] = [];
    let presets: Array<InferPreset> = [];

    // Preset selection strategy:
    // - `--presets ...`  -> use ONLY the provided presets (disables discovery)
    // - `--no-discover-presets` -> use no presets at all
    // - default -> discover presets from package.json
    const presetNames = (opts?.presets ?? []).filter((x): x is string => typeof x === "string" && x.length > 0);

    if (presetNames.length > 0) {
        presets = getPresetsFromNames(presetNames);
    } else if (opts?.discoverPresets === true) {
        presets = await discoverPresets(warnings);
    } else {
        presets = [];
    }



    const env = dnl.readEnvFile(source, { onDuplicate: opts?.warnOnDuplicates ? "warn" : "error" }, warnings);

    const lines: string[] = [];

    const importedSchemas: Array<Import> = [{ name: "define", from: "@romaintaillandier1978/dotenv-never-lies" }];
    const verbose: Array<string> = [];

    lines.push(`// ⚠️ This file was generated by dotenv-never-lies`);
    lines.push(`// Review and adjust schemas, descriptions and secrets before using`);
    lines.push("");
    lines.push(`import { z } from "zod";`);
    lines.push("");
    lines.push(`export default define({`);

    for (const [name, rawValue] of Object.entries(env)) {
        const isValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);
        const safeKey = isValidIdentifier ? name : JSON.stringify(name);
        if (!isValidIdentifier) {
            warnings.push(`Key ${name} is not a valid identifier. It has been escaped to ${safeKey}.`);
        }
        lines.push(`    ${safeKey}: {`);

        const result = findPresetEntry(presets,name,warnings);
        if(result) {
            const [origin, presetEntry] = result;
            verbose.push(`  Infer ${name} : `);
            verbose.push(`    -> inferred from preset ${result[0]}`);
            lines.push(`        // from @preset ${origin}`);
            lines.push(`        description: "${presetEntry.description}",`);
            lines.push(`        schema: ${presetEntry.code},`);
            lines.push(`        secret: ${presetEntry.secret ? "true" : "false"},`);
            lines.push(`        examples: ${presetEntry.examples ? JSON.stringify(presetEntry.examples) : "[]"},`);
            lines.push(`    },`);
            importedSchemas.push(...presetEntry.imports);
            continue;
        }


        lines.push(`        description: "TODO",`);

        const isSecret = !opts?.dontGuessSecret && guessSecret(name);

        // NO : if (rawValue === undefined || rawValue === '""' || rawValue === "''") { // WRONG !
        // Note: dotenv normalizes `FOO=`, `FOO=""` and `FOO=''` into an empty string ("").
        // At this stage, we only treat `undefined` as "variable not set".
        // Empty strings are handled by inference rules when relevant (e.g. number coercion).
        if (rawValue === undefined) {
            // undefined means the variable is not set in the .env file
            lines.push(`        schema: z.string().optional(),`);
        } else {
            const context: InferContext = { name, rawValue, imports: importedSchemas, reasons: verbose, codeWarnings: [] };

            const schema = infer(context);
            crossInfer({ inferredSchema: schema, isSecret, ...context });
            for (const w of context.codeWarnings) {
                lines.push("        // " + w);
            }
            lines.push(`        schema: ${schema.code},`);
        }
        if (isSecret) {
            lines.push(`        secret: true, //  ⚠️  inferred as secret`);
            verbose.push(`    -> inferred as secret`);
            warnings.push(`${name} inferred as secret`);
        }
        lines.push(`    },`);
    }

    lines.push(`});`);

    // insert the imported schemas at the top of the file
    insertImports(lines, importedSchemas);

    return {
        content: lines.join("\n"),
        out: target,
        warnings: [...warnings, "Generated schema is a prototype. Review schemas, descriptions and secrets before using."],
        verbose,
    };
};

const insertImports = (lines: string[], imports: Array<Import>): void => {
    if (!imports || imports.length === 0) return;
    const byFrom = new Map<string, Set<string>>();
    for (const imp of imports) {
        const current = byFrom.get(imp.from) ?? new Set<string>();
        current.add(imp.name);
        byFrom.set(imp.from, current);
    }
    const importLines: string[] = [];
    // tri par 'from' pour stabilité
    const froms = Array.from(byFrom.keys()).sort();
    for (const from of froms) {
        const names = Array.from(byFrom.get(from) ?? new Set<string>()).sort();
        if (names.length === 0) continue;
        importLines.push(`import { ${names.join(", ")} } from ${JSON.stringify(from)};`);
    }
    if (importLines.length === 0) return;
    lines.splice(4, 0, ...importLines);
};

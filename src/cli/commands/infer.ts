import path from "node:path";
import dnl from "../../index.js";
import { heuristicEngine } from "../../infer/heuristic.js";
import fs from "node:fs";
import { ExportError } from "../../errors.js";
import { Import, InferContext } from "../../infer/infer.types.js";
import { discoverPresets, findPresetEntry, getPresetsFromNames } from "../../infer/presets.js";
import { PressetDef } from "../../infer/presets.types.js";
import { InferReportEntry, InferReport, EvaluatedRule, RuleMethod } from "../../infer/report.types.js";
import { saveReport } from "../utils/report.js";
import { guessSecretRule } from "../../infer/secret.js";
import { crossEngine } from "../../infer/cross.js";

export type InferCliOptions = {
    source?: string;
    out?: string;
    force?: boolean;
    guessSecret?: boolean; // if true, the command will not try to guess secret variables
    verbose?: boolean;
    warnOnDuplicates?: boolean;
    presets?: Array<string>;
    discoverPresets?: boolean;
};

export type InferResult = {
    content: string;
    out: string;
    report: InferReport;
};

export const inferCommand = async (opts?: InferCliOptions | undefined): Promise<InferResult> => {
    // check and prepare parameters
    const source = path.resolve(process.cwd(), opts?.source ?? ".env");
    if (!fs.existsSync(source)) {
        throw new ExportError(`Source env file not found: ${source}`);
    }
    const out = opts?.out ?? "env.dnl.ts";
    const target = path.resolve(process.cwd(), out);
    if (fs.existsSync(target) && !opts?.force) {
        throw new ExportError(`${out} already exists. Use --force to overwrite.`);
    }

    // prepare variables
    const warnings: string[] = [];
    let presets: Array<PressetDef> = [];
    const codeLines: string[] = [];
    const importedSchemas: Array<Import> = [
        { name: "define", from: "@romaintaillandier1978/dotenv-never-lies" },
        { name: "z", from: "zod" },
    ];

    // prepare appliable preset
    // Preset selection strategy:
    // - `--presets ...`  -> use ONLY the provided presets (disables discovery)
    // - `--no-discover-presets` -> use no presets at all
    // - default -> discover presets from package.json
    const presetNames = (opts?.presets ?? []).filter((x): x is string => typeof x === "string" && x.length > 0);

    if (presetNames.length > 0) {
        presets = getPresetsFromNames(presetNames);
    } else if (opts?.discoverPresets === true) {
        // that will populate warnings if any
        presets = discoverPresets(warnings);
    } else {
        presets = [];
    }

    // load source
    const env = dnl.readEnvFile(source, { onDuplicate: opts?.warnOnDuplicates ? "warn" : "error" }, warnings);

    // Write file header
    codeLines.push(`// ⚠️ This file was generated by dotenv-never-lies`);
    codeLines.push(`// Review and adjust schemas, descriptions and secrets before using`);
    codeLines.push("");
    codeLines.push("");
    codeLines.push(`export default define({`);

    // prepare the report output
    const report: InferReport = {
        inputs: {
            source,
            presets: presets.map((p) => p.origin),
            discoverPresets: opts?.discoverPresets ?? true,
        },
        envVars: [],
        warnings,
    };

    // Now for each environment variable, readed from source
    for (const [name, rawValue] of Object.entries(env)) {
        // prepare the report entry for the current environment variable
        const reportEntry: InferReportEntry = {
            envVarName: name,
            evaluatedRules: new Array<EvaluatedRule<RuleMethod>>(),
            warnings: new Array<string>(),
        };

        // check if the variable name is a valid identifier
        const isValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);
        const safeKey = isValidIdentifier ? name : JSON.stringify(name);
        if (!isValidIdentifier) {
            reportEntry.warnings.push(`Key ${name} is not a valid identifier. It has been escaped to ${safeKey}.`);
        }
        // write the variable declaration to the code lines
        codeLines.push(`    ${safeKey}: {`);

        // ----------------------------------------------------------------------------------------------------------
        // Step 1 : Apply preset rules.
        // check if the variable is defined in any preset
        const pressetEvaluatedRules = findPresetEntry(presets, name);
        if (pressetEvaluatedRules) {
            reportEntry.evaluatedRules.push(...pressetEvaluatedRules);
        }
        const accepted = pressetEvaluatedRules?.find((r) => r.outcome === "accepted");
        if (accepted) {
            const {
                result: { origin, entry },
            } = accepted;
            // if the raw value matches the preset schema, write the variable declaration to the code lines
            // if raw value is undefined, the schema might or might not support optional, but let the schema decide.
            if (entry.schema.safeParse(rawValue).success) {
                codeLines.push(`        // from @preset ${origin.join(", ")}`);
                codeLines.push(`        description: "${entry.description}",`);
                codeLines.push(`        schema: ${entry.code},`);
                codeLines.push(`        secret: ${entry.secret ? "true" : "false"},`);
                if (entry.examples) {
                    codeLines.push(`        examples: ${JSON.stringify(entry.examples)},`);
                }
                codeLines.push(`    },`);
                // save to the report...
                importedSchemas.push(...entry.imports);
                report.envVars.push(reportEntry);
                // and skip the next steps, start the next environment variable.
                continue;
            }

            // if the raw value does not match the preset schema, change the outcome of the rule to rejected
            accepted.outcome = "rejected";
            accepted.result.reasons.push(`Raw value does not match preset schema`);
            reportEntry.warnings.push(`Preset "${origin}" ignored for ${name}: raw value does not match preset schema`);
        }

        codeLines.push(`        description: "TODO",`);

        // ----------------------------------------------------------------------------------------------------------
        // Step 2 : Apply secret rules.
        let isSecret = false;
        if (opts?.guessSecret ?? true) {
            const secretResult = guessSecretRule(name);
            isSecret = secretResult.isSecret;
            if (isSecret) {
                reportEntry.evaluatedRules.push({
                    ruleMethod: "secret",
                    outcome: "applied",
                    result: secretResult,
                });
                reportEntry.warnings.push(`${name} inferred as secret`);
            }
        }

        //
        // NO : if (rawValue === undefined || rawValue === '""' || rawValue === "''") { // WRONG !
        // Note: dotenv normalizes `FOO=`, `FOO=""` and `FOO=''` into an empty string ("").
        // At this stage, we only treat `undefined` as "variable not set".
        // Empty strings are handled by inference rules when relevant (e.g. number coercion).
        if (rawValue === undefined) {
            // undefined means the variable is not set in the .env file
            codeLines.push(`        schema: z.string().optional(),`);
        } else {
            const context: InferContext = { name, rawValue, imports: importedSchemas, reasons: [], codeWarnings: [] };

            // ----------------------------------------------------------------------------------------------------------
            // Step 3 : Apply heuristic rules.
            const evaluatedRules = heuristicEngine(context);
            reportEntry.evaluatedRules.push(...evaluatedRules);

            // the process of checking rule, garanties that exactly one rule will be accepted.
            const generated = evaluatedRules.find((r) => r.outcome === "accepted")?.result.generated;

            if (generated) {
                // ----------------------------------------------------------------------------------------------------------
                // Step 4 : Apply cross inference rules.
                // TODO : check this.
                const evaluatedCrossRules = crossEngine({ inferredSchema: generated, isSecret, ...context });
                reportEntry.evaluatedRules.push(...evaluatedCrossRules);

                for (const R of evaluatedCrossRules) {
                    if (R.result?.codeWarnings) {
                        for (const w of R.result.codeWarnings) {
                            codeLines.push("        // " + w);
                        }
                    }
                }
                codeLines.push(`        schema: ${generated.code},`);
            }
        }
        if (isSecret) {
            codeLines.push(`        secret: true, //  ⚠️  inferred as secret`);
        }
        codeLines.push(`    },`);
        report.envVars.push(reportEntry);
    }

    codeLines.push(`});`);

    codeLines.push("/**");
    codeLines.push(" * ----------------------------------------------------------------------------------------------------------");
    codeLines.push(" * ℹ️ DNL TIP");
    codeLines.push(" *");
    codeLines.push(" * Once this schema is fully documented (descriptions, schemas, secrets, required flags),");
    codeLines.push(" * run:");
    codeLines.push(" *");
    codeLines.push(" *   dnl types");
    codeLines.push(" *");
    codeLines.push(" * This will generate `env.dnl.d.ts` and enable rich IntelliSense directly in your IDE.");
    codeLines.push(" *");
    codeLines.push(" * Docs: https://github.com/romaintaillandier1978/dotenv-never-lies/blob/master/docs/commands/types.md");
    codeLines.push(" *       dnl types --help");
    codeLines.push(" * ----------------------------------------------------------------------------------------------------------");
    codeLines.push(" */");

    // insert the imported schemas at the top of the file
    insertImports(codeLines, importedSchemas);

    report.warnings.push("Generated schema is a prototype. Review schemas, descriptions and secrets before using.");

    //console.log("report : " + JSON.stringify(report, null, 2));
    saveReport(report);

    return {
        content: codeLines.join("\n"),
        out: target,
        report,
    };
};

const insertImports = (lines: string[], imports: Array<Import>): void => {
    if (!imports || imports.length === 0) return;
    const byFrom = new Map<string, Set<string>>();
    for (const imp of imports) {
        const current = byFrom.get(imp.from) ?? new Set<string>();
        current.add(imp.name);
        byFrom.set(imp.from, current);
    }
    const importLines: string[] = [];
    // tri par 'from' pour stabilité
    const froms = Array.from(byFrom.keys()).sort();
    for (const from of froms) {
        const names = Array.from(byFrom.get(from) ?? new Set<string>()).sort();
        if (names.length === 0) continue;
        importLines.push(`import { ${names.join(", ")} } from ${JSON.stringify(from)};`);
    }
    if (importLines.length === 0) return;
    lines.splice(3, 0, ...importLines);
};
